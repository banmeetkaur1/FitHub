Object.defineProperty(exports, '__esModule', { value: true });

var AsyncStorage = require('@react-native-async-storage/async-storage');
var NetInfo = require('@react-native-community/netinfo');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var AsyncStorage__default = /*#__PURE__*/_interopDefault(AsyncStorage);
var NetInfo__default = /*#__PURE__*/_interopDefault(NetInfo);

var parseData = (persistedData, fallback) => {
  try {
    if (persistedData) {
      return JSON.parse(persistedData);
    }
  } catch (_err) {}
  return fallback;
};
var disconnect;

/** React Native storage adapter persisting to `AsyncStorage`. */

/** Creates a {@link StorageAdapter} which uses React Nativeâ€™s `AsyncStorage`.
 *
 * @param opts - A {@link StorageOptions} configuration object.
 * @returns the created {@link DefaultAsyncStorage} adapter.
 *
 * @remarks
 * `makeAsyncStorage` creates a storage adapter for React Native,
 * which persisted to `AsyncStorage` via the `@react-native-async-storage/async-storage`
 * package.
 *
 * Note: We have no data on stability of this storage and our Offline Support
 * for large APIs or longterm use. Proceed with caution.
 */
var makeAsyncStorage = ({
  dataKey = 'graphcache-data',
  metadataKey = 'graphcache-metadata',
  maxAge = 7
} = {}) => {
  var todayDayStamp = Math.floor(new Date().valueOf() / (1000 * 60 * 60 * 24));
  var allData = {};
  return {
    readData: async () => {
      if (!Object.keys(allData).length) {
        var persistedData = null;
        try {
          persistedData = await AsyncStorage__default["default"].getItem(dataKey);
        } catch (_err) {}
        var parsed = parseData(persistedData, {});
        Object.assign(allData, parsed);
      }

      // clean up old data
      var syncNeeded = false;
      Object.keys(allData).forEach(dayStamp => {
        if (todayDayStamp - Number(dayStamp) > maxAge) {
          syncNeeded = true;
          delete allData[dayStamp];
        }
      });
      if (syncNeeded) {
        try {
          await AsyncStorage__default["default"].setItem(dataKey, JSON.stringify(allData));
        } catch (_err) {}
      }
      return Object.assign({}, ...Object.keys(allData).map(key => allData[key]));
    },
    writeData: async delta => {
      if (!Object.keys(allData).length) {
        var persistedData = null;
        try {
          persistedData = await AsyncStorage__default["default"].getItem(dataKey);
        } catch (_err) {}
        var parsed = parseData(persistedData, {});
        Object.assign(allData, parsed);
      }
      var deletedKeys = {};
      Object.keys(delta).forEach(key => {
        if (delta[key] === undefined) {
          deletedKeys[key] = undefined;
        }
      });
      for (var key in allData) {
        allData[key] = Object.assign(allData[key], deletedKeys);
      }
      allData[todayDayStamp] = Object.assign(allData[todayDayStamp] || {}, delta);
      try {
        await AsyncStorage__default["default"].setItem(dataKey, JSON.stringify(allData));
      } catch (_err) {}
    },
    writeMetadata: async data => {
      try {
        await AsyncStorage__default["default"].setItem(metadataKey, JSON.stringify(data));
      } catch (_err) {}
    },
    readMetadata: async () => {
      var persistedData = null;
      try {
        persistedData = await AsyncStorage__default["default"].getItem(metadataKey);
      } catch (_err) {}
      return parseData(persistedData, []);
    },
    onOnline: cb => {
      if (disconnect) {
        disconnect();
        disconnect = undefined;
      }
      disconnect = NetInfo__default["default"].addEventListener(({
        isConnected
      }) => {
        if (isConnected) {
          cb();
        }
      });
    },
    clear: async () => {
      try {
        allData = {};
        await AsyncStorage__default["default"].removeItem(dataKey);
        await AsyncStorage__default["default"].removeItem(metadataKey);
      } catch (_err) {}
    }
  };
};

exports.makeAsyncStorage = makeAsyncStorage;
//# sourceMappingURL=urql-storage-rn.js.map
